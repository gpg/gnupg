diff --git Makefile.am Makefile.am
index 680fe1be1..b59e9e3ec 100644
--- Makefile.am
+++ Makefile.am
@@ -189,7 +189,7 @@ release:
 	 $(MAKE) -f  $(RELEASE_NAME)/build-aux/speedo.mk w32-release ;\
 	 echo "/* Build finished at $$(date -uIseconds) */" ;\
          echo "/*" ;\
-	 echo " * Please run the final step interactivly:" ;\
+	 echo " * Please run the final step interactively:" ;\
 	 echo " *   make sign-release" ;\
 	 echo " */" ;\
 	) 2>&1 | tee "$(RELEASE_NAME).buildlog"
diff --git NEWS NEWS
index 27f78b14c..bfa2e72dd 100644
--- NEWS
+++ NEWS
@@ -98,7 +98,7 @@ Noteworthy changes in version 2.3.0 (unreleased)
   * dirmngr: Fallback to CRL if no default OCSP responder is configured.
 
   * dirmngr: Implement CRL fetching via https.  Here a redirection to
-    http is explictly allowed.
+    http is explicitly allowed.
 
   * dirmngr: Make LDAP searching and CRL fetching work under Windows.
     This stopped working with 2.1.  [#3937]
@@ -959,7 +959,7 @@ Noteworthy changes in version 2.1.11 (2016-01-26)
 
  * gpg: Emit PROGRESS status lines during key generation.
 
- * gpg: Don't check for ambigious or non-matching key specification in
+ * gpg: Don't check for ambiguous or non-matching key specification in
    the config file or given to --encrypt-to.  This feature will return
    in 2.3.x.
 
@@ -986,7 +986,7 @@ Noteworthy changes in version 2.1.11 (2016-01-26)
  * dirmmgr: All configured keyservers are now searched.
 
  * dirmngr: Install CA certificate for hkps.pool.sks-keyservers.net.
-   Use this certiticate even if --hkp-cacert is not used.
+   Use this certificate even if --hkp-cacert is not used.
 
  * gpgtar: Add actual encryption code.  gpgtar does now fully replace
    gpg-zip.
@@ -1020,7 +1020,7 @@ Noteworthy changes in version 2.1.10 (2015-12-04)
  * gpg: New option --only-sign-text-ids to exclude photo IDs from key
    signing.
 
- * gpg: Check for ambigious or non-matching key specification in the
+ * gpg: Check for ambiguous or non-matching key specification in the
    config file or given to --encrypt-to.
 
  * gpg: Show the used card reader with --card-status.
@@ -1310,7 +1310,7 @@ Noteworthy changes in version 2.1.1 (2014-12-16)
 
  * gpg: Fixed regression in --refresh-keys.
 
- * gpg: Fixed regresion in %g and %p codes for --sig-notation.
+ * gpg: Fixed regression in %g and %p codes for --sig-notation.
 
  * gpg: Fixed best matching hash algo detection for ECDSA and EdDSA.
 
@@ -1390,7 +1390,7 @@ Noteworthy changes in version 2.1.0 (2014-11-06)
 
  * gpg: Default keyring is now created with a .kbx suffix.
 
- * gpg: Add a shortcut to the key capabilies menu (e.g. "=e" sets the
+ * gpg: Add a shortcut to the key capabilities menu (e.g. "=e" sets the
    encryption capabilities).
 
  * gpg: Fixed obsolete options parsing.
@@ -1582,7 +1582,7 @@ Noteworthy changes in version 2.1.0 (2014-11-06)
  * scdaemon: Does not anymore block after changing a card (regression
    fix).
 
- * tools: gpg-connect-agent does now proberly display the help output
+ * tools: gpg-connect-agent does now properly display the help output
    for "SCD HELP" commands.
 
 
@@ -1707,7 +1707,7 @@ Noteworthy changes in version 2.0.13 (2009-09-04)
  * Add hack to the internal CCID driver to allow the use of some
    Omnikey based card readers with 2048 bit keys.
 
- * GPG now repeatly asks the user to insert the requested OpenPGP
+ * GPG now repeatedly asks the user to insert the requested OpenPGP
    card.  This can be disabled with --limit-card-insert-tries=1.
 
  * Minor bug fixes.
@@ -1833,7 +1833,7 @@ Noteworthy changes in version 2.0.9 (2008-03-26)
 
  * Extended the PKITS framework.
 
- * Fixed a bug in the ambigious name detection.
+ * Fixed a bug in the ambiguous name detection.
 
  * Fixed possible memory corruption while importing OpenPGP keys (bug
    introduced with 2.0.8). [CVE-2008-1530]
@@ -2383,7 +2383,7 @@ Noteworthy changes in version 1.9.2 (2003-11-17)
    command but from the menu provided by the new --card-edit command.
 
  * PINs are now properly cached and there are only 2 PINs visible.
-   The 3rd PIN (CHV2) is internally syncronized with the regular PIN.
+   The 3rd PIN (CHV2) is internally synchronized with the regular PIN.
 
  * All kind of other internal stuff.
 
@@ -3087,7 +3087,7 @@ Noteworthy changes in version 1.0.1 (1999-12-16)
     * Fixed some minor bugs and the problem with conventional encrypted
       packets which did use the gpg v3 partial length headers.
 
-    * Add Indonesian and Portugese translations.
+    * Add Indonesian and Portuguese translations.
 
     * Fixed a bug with symmetric-only encryption using the non-default 3DES.
       The option --emulate-3des-s2k-bug may be used to decrypt documents
@@ -3190,7 +3190,7 @@ Noteworthy changes in version 0.9.8 (1999-06-26)
 
     * New option --with-key-data to list the public key parameters.
       New option -N to insert notations and a --set-policy-url.
-      A couple of other options to allow reseting of options.
+      A couple of other options to allow resetting of options.
 
     * Better support for HPUX.
 
diff --git agent/command-ssh.c agent/command-ssh.c
index df63ed713..e6d31a4a2 100644
--- agent/command-ssh.c
+++ agent/command-ssh.c
@@ -2751,7 +2751,7 @@ data_hash (unsigned char *data, size_t data_n,
    allow the use of signature algorithms that implement the hashing
    internally (e.g. Ed25519).  On success the created signature is
    stored in ssh format at R_SIG and it's size at R_SIGLEN; the caller
-   must use es_free to releaase this memory.  */
+   must use es_free to release this memory.  */
 static gpg_error_t
 data_sign (ctrl_t ctrl, ssh_key_type_spec_t *spec,
            const void *hash, size_t hashlen,
diff --git agent/divert-scd.c agent/divert-scd.c
index b85b490c1..1cb209d8e 100644
--- agent/divert-scd.c
+++ agent/divert-scd.c
@@ -195,7 +195,7 @@ has_percent0A_suffix (const char *string)
    string with the passphrase, the buffer may optionally be padded
    with arbitrary characters.
 
-   If DESC_TEXT is not NULL it can be used as further informtion shown
+   If DESC_TEXT is not NULL it can be used as further information shown
    atop of the INFO message.
 
    INFO gets displayed as part of a generic string.  However if the
diff --git agent/gpg-agent.c agent/gpg-agent.c
index 1fdc94d0f..9cb26dfd2 100644
--- agent/gpg-agent.c
+++ agent/gpg-agent.c
@@ -2108,7 +2108,7 @@ get_agent_scd_notify_event (void)
                                  GetCurrentProcess(), &h2,
                                  EVENT_MODIFY_STATE|SYNCHRONIZE, TRUE, 0))
         {
-          log_error ("setting syncronize for scd notify event failed: %s\n",
+          log_error ("setting synchronize for scd notify event failed: %s\n",
                      w32_strerror (-1) );
           CloseHandle (h);
         }
diff --git agent/keyformat.txt agent/keyformat.txt
index 2e48b346e..032454120 100644
--- agent/keyformat.txt
+++ agent/keyformat.txt
@@ -234,7 +234,7 @@ The currently defined protection modes are:
      (csum n)
      (protection PROTTYPE PROTALGO IV S2KMODE S2KHASH S2KSALT S2KCOUNT)))
 
-  Note that the public key paramaters in SKEY are duplicated and
+  Note that the public key parameters in SKEY are duplicated and
   should be identical to their copies in the standard parameter
   elements.  Here is an example of an entire protected private key
   using this format:
diff --git agent/learncard.c agent/learncard.c
index abe1dd0bf..f3219ed8f 100644
--- agent/learncard.c
+++ agent/learncard.c
@@ -40,7 +40,7 @@ struct keypair_info_s
   char hexgrip[1];   /* The keygrip (i.e. a hash over the public key
                         parameters) formatted as a hex string.
                         Allocated somewhat large to also act as
-                        memeory for the above ID field. */
+                        memory for the above ID field. */
 };
 typedef struct keypair_info_s *KEYPAIR_INFO;
 
diff --git build-aux/speedo.mk build-aux/speedo.mk
index d9b4a7515..bf8fcec5a 100644
--- build-aux/speedo.mk
+++ build-aux/speedo.mk
@@ -970,7 +970,7 @@ else
 endif
 	@touch $(stampdir)/stamp-$(1)-01-configure
 
-# Note that unpack has no 64 bit version becuase it is just the source.
+# Note that unpack has no 64 bit version because it is just the source.
 # Fixme: We should use templates to create the standard and w64
 # version of these rules.
 $(stampdir)/stamp-w64-$(1)-01-configure: $(stampdir)/stamp-$(1)-00-unpack
@@ -1283,7 +1283,7 @@ endif
 
 
 #
-# Check availibility of standard tools
+# Check availability of standard tools
 #
 check-tools:
 
diff --git common/argparse.c common/argparse.c
index 331998bb2..db0b7e079 100644
--- common/argparse.c
+++ common/argparse.c
@@ -408,7 +408,7 @@ static void
 store_alias( ARGPARSE_ARGS *arg, char *name, char *value )
 {
     /* TODO: replace this dummy function with a rea one
-     * and fix the probelms IRIX has with (ALIAS_DEV)arg..
+     * and fix the problems IRIX has with (ALIAS_DEV)arg..
      * used as lvalue
      */
   (void)arg;
@@ -439,7 +439,7 @@ ignore_invalid_option_p (ARGPARSE_ARGS *arg, const char *keyword)
 
 /* Add the keywords up to the next LF to the list of to be ignored
    options.  After returning FP will either be at EOF or the next
-   character read wll be the first of a new line.  The function
+   character read will be the first of a new line.  The function
    returns 0 on success or true on malloc failure.  */
 static int
 ignore_invalid_option_add (ARGPARSE_ARGS *arg, FILE *fp)
@@ -1280,7 +1280,7 @@ long_opt_strlen( ARGPARSE_OPTS *o )
  *    this option
  *  - a description,ine which starts with a '@' and is followed by
  *    any other characters is printed as is; this may be used for examples
- *    ans such.
+ *    and such.
  *  - A description which starts with a '|' outputs the string between this
  *    bar and the next one as arguments of the long option.
  */
diff --git common/audit.h common/audit.h
index 4ef2645da..05f39533d 100644
--- common/audit.h
+++ common/audit.h
@@ -185,7 +185,7 @@ typedef enum
        if no real recipient has been given.  */
 
     AUDIT_SESSION_KEY,     /* string */
-    /* Mark the creation or availibility of the session key.  The
+    /* Mark the creation or availability of the session key.  The
        parameter is the algorithm ID.  */
 
     AUDIT_ENCRYPTED_TO,   /* cert, err */
diff --git common/dotlock.c common/dotlock.c
index 5227bb64e..a3441d354 100644
--- common/dotlock.c
+++ common/dotlock.c
@@ -140,7 +140,7 @@
    you pass (0) instead of (-1) the function does not wait in case the
    file is already locked but returns -1 and sets ERRNO to EACCES.
    Any other positive value for the second parameter is considered a
-   timeout valuie in milliseconds.
+   timeout value in milliseconds.
 
    To release the lock you call:
 
diff --git common/iobuf.c common/iobuf.c
index 8f52f7f5c..7ed2b28e9 100644
--- common/iobuf.c
+++ common/iobuf.c
@@ -68,8 +68,8 @@
 
 /*-- End configurable part.  --*/
 
-/* The size of the iobuffers.  This can be chnages using the
- * iobuf_set_buffer_size fucntion.  */
+/* The size of the iobuffers.  This can be changed using the
+ * iobuf_set_buffer_size function.  */
 static unsigned int iobuf_buffer_size = DEFAULT_IOBUF_BUFFER_SIZE;
 
 
diff --git common/mkerrors common/mkerrors
index 138d3c1d1..2a6960ab6 100755
--- common/mkerrors
+++ common/mkerrors
@@ -30,7 +30,7 @@ cat <<EOF
  * gnupg_strerror:
  * @err:  Error code
  *
- * This function returns a textual representaion of the given
+ * This function returns a textual representation of the given
  * errorcode. If this is an unknown value, a string with the value
  * is returned (Beware: it is hold in a static buffer).
  *
diff --git common/mkerrtok common/mkerrtok
index e6310722a..49c10e595 100755
--- common/mkerrtok
+++ common/mkerrtok
@@ -26,7 +26,7 @@ cat <<EOF
  * gnupg_error_token:
  * @err:  Error code
  *
- * This function returns a textual representaion of the given
+ * This function returns a textual representation of the given
  * errorcode. If this is an unknown value, a static string is returned.
  * This function differs from gnupg_strerror that it yields the string
  * representation of the macro which is never subject to i18n.
diff --git common/openpgp-oid.c common/openpgp-oid.c
index d800e7d57..059fff905 100644
--- common/openpgp-oid.c
+++ common/openpgp-oid.c
@@ -184,7 +184,7 @@ openpgp_oid_from_str (const char *string, gcry_mpi_t *r_mpi)
 }
 
 
-/* Return a malloced string represenation of the OID in the opaque MPI
+/* Return a malloced string representation of the OID in the opaque MPI
    A.  In case of an error NULL is returned and ERRNO is set.  */
 char *
 openpgp_oid_to_str (gcry_mpi_t a)
diff --git common/percent.c common/percent.c
index eeb026fbe..7afd7fefc 100644
--- common/percent.c
+++ common/percent.c
@@ -36,7 +36,7 @@
    failure.
 
    Note that we also escape the quote character to work around a bug
-   in the mingw32 runtime which does not correcty handle command line
+   in the mingw32 runtime which does not correctly handle command line
    quoting.  We correctly double the quote mark when calling a program
    (i.e. gpg-protect-tool), but the pre-main code does not notice the
    double quote as an escaped quote.  We do this also on POSIX systems
diff --git common/sexp-parse.h common/sexp-parse.h
index 4f77f1430..0403d65f5 100644
--- common/sexp-parse.h
+++ common/sexp-parse.h
@@ -105,7 +105,7 @@ smatch (unsigned char const **buf, size_t buflen, const char *token)
 }
 
 /* Format VALUE for use as the length indicatior of an S-expression.
-   The caller needs to provide a buffer HELP_BUFFER wth a length of
+   The caller needs to provide a buffer HELP_BUFFER with a length of
    HELP_BUFLEN.  The return value is a pointer into HELP_BUFFER with
    the formatted length string.  The colon and a trailing nul are
    appended.  HELP_BUFLEN must be at least 3 - a more useful value is
diff --git common/simple-pwquery.c common/simple-pwquery.c
index e7f4af341..86a420ca6 100644
--- common/simple-pwquery.c
+++ common/simple-pwquery.c
@@ -75,7 +75,7 @@
 
 
 /* Name of the socket to be used.  This is a kludge to keep on using
-   the existsing code despite that we only support a standard socket.  */
+   the existing code despite that we only support a standard socket.  */
 static char *default_gpg_agent_info;
 
 
diff --git common/t-exechelp.c common/t-exechelp.c
index cf967fcc7..3bf082bbb 100644
--- common/t-exechelp.c
+++ common/t-exechelp.c
@@ -131,7 +131,7 @@ test_close_all_fds (void)
   free (array);
 
   /* Now let's check the realloc we use.  We do this and the next
-     tests only if we are allowed to open enought descriptors.  */
+     tests only if we are allowed to open enough descriptors.  */
   if (get_max_fds () > 32)
     {
       int except[] = { 20, 23, 24, -1 };
diff --git configure.ac configure.ac
index 78a03c420..f0e696618 100644
--- configure.ac
+++ configure.ac
@@ -1481,7 +1481,7 @@ if test "$use_regex" = yes ; then
     use_regex=no
   else
     if test x"$cross_compiling" = xyes; then
-      AC_MSG_WARN([cross compiling; assuming regexp libray is not broken])
+      AC_MSG_WARN([cross compiling; assuming regexp library is not broken])
     else
       AC_CACHE_CHECK([whether your system's regexp library is broken],
        [gnupg_cv_regex_broken],
diff --git dirmngr/cdb.h dirmngr/cdb.h
index 0c0d2702a..5d46f6956 100644
--- dirmngr/cdb.h
+++ dirmngr/cdb.h
@@ -85,7 +85,7 @@ int cdb_make_put(struct cdb_make *cdbmp,
 		 const void *key, cdbi_t klen,
 		 const void *val, cdbi_t vlen,
 		 int flag);
-#define CDB_PUT_ADD	0	/* add unconditionnaly, like cdb_make_add() */
+#define CDB_PUT_ADD	0	/* add unconditionally, like cdb_make_add() */
 #define CDB_PUT_REPLACE	1	/* replace: do not place to index OLD record */
 #define CDB_PUT_INSERT	2	/* add only if not already exists */
 #define CDB_PUT_WARN	3	/* add unconditionally but ret. 1 if exists */
diff --git dirmngr/cdblib.c dirmngr/cdblib.c
index 827399f7e..5f49bcdd1 100644
--- dirmngr/cdblib.c
+++ dirmngr/cdblib.c
@@ -19,7 +19,7 @@
    length, meaning that corresponding hash table is empty.
 
    Right after toc section, data section follows without any
-   alingment.  It consists of series of records, each is a key length,
+   alignment.  It consists of series of records, each is a key length,
    value (data) length, key and value.  Again, key and value length
    are 4-byte unsigned integers.  Each next record follows previous
    without any special alignment.
@@ -52,7 +52,7 @@
    beginning of a table).  When hash value in question is found in
    hash table, look to key of corresponding record, comparing it with
    key in question.  If them of the same length and equals to each
-   other, then record is found, overwise, repeat with next hash table
+   other, then record is found, otherwise, repeat with next hash table
    slot.  Note that there may be several records with the same key.
 */
 
diff --git dirmngr/crlcache.c dirmngr/crlcache.c
index fbe3beea1..a2867be54 100644
--- dirmngr/crlcache.c
+++ dirmngr/crlcache.c
@@ -1782,7 +1782,7 @@ crl_parse_insert (ctrl_t ctrl, ksba_crl_t crl,
             ksba_sexp_t keyid;
 
             /* We need to look for the issuer only after having read
-               all items.  The issuer itselfs comes before the items
+               all items.  The issuer itself comes before the items
                but the optional authorityKeyIdentifier comes after the
                items. */
             err = ksba_crl_get_issuer (crl, &crlissuer);
@@ -1907,7 +1907,7 @@ get_crl_number (ksba_crl_t crl)
 
 
 /* Return the authorityKeyIdentifier or NULL if it is not available.
-   The issuer name may consists of several parts - they are delimted by
+   The issuer name may consists of several parts - they are delimited by
    0x01. */
 static char *
 get_auth_key_id (ksba_crl_t crl, char **serialno)
diff --git dirmngr/dirmngr.c dirmngr/dirmngr.c
index 6fdfe36c2..55b2b4f33 100644
--- dirmngr/dirmngr.c
+++ dirmngr/dirmngr.c
@@ -338,7 +338,7 @@ static int active_connections;
  * thread to run background network tasks.  */
 static int network_activity_seen;
 
-/* A list of filenames registred with --hkp-cacert.  */
+/* A list of filenames registered with --hkp-cacert.  */
 static strlist_t hkp_cacert_filenames;
 
 
@@ -411,7 +411,7 @@ my_strusage( int level )
 
 /* Callback from libksba to hash a provided buffer.  Our current
    implementation does only allow SHA-1 for hashing. This may be
-   extended by mapping the name, testing for algorithm availibility
+   extended by mapping the name, testing for algorithm availability
    and adjust the length checks accordingly. */
 static gpg_error_t
 my_ksba_hash_buffer (void *arg, const char *oid,
@@ -520,7 +520,7 @@ set_tor_mode (void)
 {
   if (dirmngr_use_tor ())
     {
-      /* Enable Tor mode and when called again force a new curcuit
+      /* Enable Tor mode and when called again force a new circuit
        * (e.g. on SIGHUP).  */
       enable_dns_tormode (1);
       if (assuan_sock_set_flag (ASSUAN_INVALID_FD, "tor-mode", 1))
@@ -752,7 +752,7 @@ parse_rereadable_options (ARGPARSE_ARGS *pargs, int reread)
 }
 
 
-/* This fucntion is called after option parsing to adjust some values
+/* This function is called after option parsing to adjust some values
  * and call option setup functions.  */
 static void
 post_option_parsing (void)
diff --git dirmngr/dirmngr_ldap.c dirmngr/dirmngr_ldap.c
index 8452c3ba0..dd7e4bda5 100644
--- dirmngr/dirmngr_ldap.c
+++ dirmngr/dirmngr_ldap.c
@@ -417,9 +417,9 @@ set_timeout (my_opt_t myopt)
           sec_attr.nLength = sizeof sec_attr;
           sec_attr.bInheritHandle = FALSE;
 
-          /* Create a manual resetable timer.  */
+          /* Create a manual resettable timer.  */
           timer = CreateWaitableTimer (NULL, TRUE, NULL);
-          /* Intially set the timer.  */
+          /* Initially set the timer.  */
           SetWaitableTimer (timer, &due_time, 0, NULL, NULL, 0);
 
           if (CreateThread (&sec_attr, 0, alarm_thread, timer, 0, &tid))
diff --git dirmngr/dns-stuff.c dirmngr/dns-stuff.c
index 09b17c0fb..987c9a6af 100644
--- dirmngr/dns-stuff.c
+++ dirmngr/dns-stuff.c
@@ -151,7 +151,7 @@ static char tor_socks_password[20];
 
 
 #ifdef USE_LIBDNS
-/* Libdns gobal data.  */
+/* Libdns global data.  */
 struct libdns_s
 {
   struct dns_resolv_conf *resolv_conf;
diff --git dirmngr/http-ntbtls.c dirmngr/http-ntbtls.c
index ed4cdd496..924b8b25f 100644
--- dirmngr/http-ntbtls.c
+++ dirmngr/http-ntbtls.c
@@ -55,7 +55,7 @@ gnupg_http_tls_verify_cb (void *opaque,
   log_assert (ctrl && ctrl->magic == SERVER_CONTROL_MAGIC);
   log_assert (!ntbtls_check_context (tls));
 
-  /* Get the peer's certs fron ntbtls.  */
+  /* Get the peer's certs from ntbtls.  */
   for (idx = 0;
        (cert = ntbtls_x509_get_peer_cert (tls, idx)); idx++)
     {
diff --git dirmngr/ldap.c dirmngr/ldap.c
index cb3c0b763..a04bb97a2 100644
--- dirmngr/ldap.c
+++ dirmngr/ldap.c
@@ -388,7 +388,7 @@ parse_one_pattern (const char *pattern)
 }
 
 /* Take the string STRING and escape it according to the URL rules.
-   Retun a newly allocated string. */
+   Return a newly allocated string. */
 static char *
 escape4url (const char *string)
 {
diff --git dirmngr/misc.c dirmngr/misc.c
index 1270b834d..9ad60d59f 100644
--- dirmngr/misc.c
+++ dirmngr/misc.c
@@ -637,7 +637,7 @@ armor_data (char **r_string, const void *data, size_t datalen)
 }
 
 
-/* Copy all data from IN to OUT.  OUT may be NULL to use this fucntion
+/* Copy all data from IN to OUT.  OUT may be NULL to use this function
  * as a dummy reader.  */
 gpg_error_t
 copy_stream (estream_t in, estream_t out)
diff --git dirmngr/ocsp.c dirmngr/ocsp.c
index ca28960e4..9f6d7c874 100644
--- dirmngr/ocsp.c
+++ dirmngr/ocsp.c
@@ -343,7 +343,7 @@ validate_responder_cert (ctrl_t ctrl, ksba_cert_t cert,
 
          Note, that in theory we could simply ask the client via an
          inquire to validate a certificate but this might involve
-         calling DirMngr again recursivly - we can't do that as of now
+         calling DirMngr again recursively - we can't do that as of now
          (neither DirMngr nor gpgsm have the ability for concurrent
          access to DirMngr.   */
 
@@ -391,7 +391,7 @@ check_signature_core (ctrl_t ctrl, ksba_cert_t cert, gcry_sexp_t s_sig,
 }
 
 
-/* Check the signature of an OCSP repsonse.  OCSP is the context,
+/* Check the signature of an OCSP response.  OCSP is the context,
    S_SIG the signature value and MD the handle of the hash we used for
    the response.  This function automagically finds the correct public
    key.  If SIGNER_FPR_LIST is not NULL, the default OCSP reponder has been
@@ -761,7 +761,7 @@ ocsp_isvalid (ctrl_t ctrl, ksba_cert_t cert, const char *cert_fpr,
         err = gpg_error (GPG_ERR_TIME_CONFLICT);
     }
 
-  /* Check that we are not beyound NEXT_UPDATE  (plus some extra time). */
+  /* Check that we are not beyond NEXT_UPDATE  (plus some extra time). */
   if (*next_update)
     {
       gnupg_copy_time (tmp_time, next_update);
diff --git dirmngr/t-http.c dirmngr/t-http.c
index 2fc0a465c..8b32613b6 100644
--- dirmngr/t-http.c
+++ dirmngr/t-http.c
@@ -137,7 +137,7 @@ my_http_tls_verify_cb (void *opaque,
   (void)session;
   (void)http_flags;
 
-  /* Get the peer's certs fron ntbtls.  */
+  /* Get the peer's certs from ntbtls.  */
   for (idx = 0;
        (cert = ntbtls_x509_get_peer_cert (tls_context, idx)); idx++)
     {
diff --git dirmngr/workqueue.c dirmngr/workqueue.c
index 2cb8573e8..a47cdebc8 100644
--- dirmngr/workqueue.c
+++ dirmngr/workqueue.c
@@ -116,7 +116,7 @@ workqueue_add_task (wqtask_t func, const char *args, unsigned int session_id,
 
 
 /* Run the task described by ITEM.  ITEM must have been detached from
- * the workqueue; its ownership is transferred to this fucntion.  */
+ * the workqueue; its ownership is transferred to this function.  */
 static void
 run_a_task (ctrl_t ctrl, wqitem_t item)
 {
diff --git doc/DETAILS doc/DETAILS
index eb6d7dd4b..9db0b5027 100644
--- doc/DETAILS
+++ doc/DETAILS
@@ -126,7 +126,7 @@ described here.
 *** Field 4 - Public key algorithm
 
     The values here are those from the OpenPGP specs or if they are
-    greather than 255 the algorithm ids as used by Libgcrypt.
+    greater than 255 the algorithm ids as used by Libgcrypt.
 
 *** Field 5 - KeyID
 
@@ -544,7 +544,7 @@ pkd:0:1024:B665B1435F4C2 .... FF26ABB:
 *** DECRYPTION_KEY <fpr> <fpr2> <otrust>
     This line is emitted when a public key decryption succeeded in
     providing a session key.  <fpr> is the hexified fingerprint of the
-    actual key used for descryption.  <fpr2> is the fingerprint of the
+    actual key used for decryption.  <fpr2> is the fingerprint of the
     primary key.  <otrust> is the letter with the ownertrust; this is
     in general a 'u' which stands for ultimately trusted.
 *** DECRYPTION_INFO <mdc_method> <sym_algo> [<aead_algo>]
@@ -700,7 +700,7 @@ pkd:0:1024:B665B1435F4C2 .... FF26ABB:
 
        -  0 :: No specific reason given
        -  1 :: Not Found
-       -  2 :: Ambigious specification
+       -  2 :: Ambiguous specification
        -  3 :: Wrong key usage
        -  4 :: Key revoked
        -  5 :: Key expired
@@ -1016,7 +1016,7 @@ pkd:0:1024:B665B1435F4C2 .... FF26ABB:
       - 2 :: bad PIN
 
 *** SC_OP_SUCCESS
-    A smart card operaion succeeded.  This status is only printed for
+    A smart card operation succeeded.  This status is only printed for
     certain operation and is mostly useful to check whether a PIN
     change really worked.
 
@@ -1073,7 +1073,7 @@ pkd:0:1024:B665B1435F4C2 .... FF26ABB:
     Deleting a key failed.  Reason codes are:
     - 1 :: No such key
     - 2 :: Must delete secret key first
-    - 3 :: Ambigious specification
+    - 3 :: Ambiguous specification
     - 4 :: Key is stored on a smartcard.
 
 *** PROGRESS <what> <char> <cur> <total> [<units>]
diff --git doc/HACKING doc/HACKING
index 17c58269b..4781bf62c 100644
--- doc/HACKING
+++ doc/HACKING
@@ -150,7 +150,7 @@ Note that such a comment will be removed if the git commit option
       if ( 42 == foo )
 #+end_src
     this is harder to read and modern compilers are pretty good in
-    detecing accidential assignments.  It is also suggested not to
+    detecting accidental assignments.  It is also suggested not to
     compare to 0 or NULL but to test the value direct or with a '!';
     this makes it easier to see that a boolean test is done.
   - We use our own printf style functions like =es_printf=, and
@@ -395,7 +395,7 @@ The *secure versions allocate memory in the secure memory.  That is,
 swapping out of this memory is avoided and is gets overwritten on
 free.  Use this for passphrases, session keys and other sensitive
 material.  This memory set aside for secure memory is linited to a few
-k.  In general the function don't print a memeory message and
+k.  In general the function don't print a memory message and
 terminate the process if there is not enough memory available.  The
 "try" versions of the functions return NULL instead.
 
diff --git doc/Notes doc/Notes
index 19241b7b7..de575bab7 100644
--- doc/Notes
+++ doc/Notes
@@ -1,5 +1,5 @@
 
-Add an infor page for watchgnupg.
+Add an info page for watchgnupg.
 
 > * How to mark a CA certificate as trusted.
 
@@ -57,7 +57,7 @@ or
 
 In general you should first import the root certificates and then down
 to the end user certificate.  You may put all into one file and gpgsm
-will do the right thing in this case independend of the order.  
+will do the right thing in this case independent of the order.  
 
 While verifying a signature, all included certificates are
 automagically imported.
@@ -82,7 +82,7 @@ you get an output like:
   uid:::::::::CN=Werner Koch,OU=test,O=g10 Code,C=de::
   uid:::::::::<wk@g10code.de>::
 
-This should be familar to advanced gpg-users; see doc/DETAILS in gpg
+This should be familiar to advanced gpg-users; see doc/DETAILS in gpg
 1.3 (CVS HEAD) for a description of the records.  The value in the
 "grp" tagged record is the so called keygrip and you should find a
 file ~/.gnupg/private-keys-v1.d/C92DB9CFD588ADE846BE3AC4E7A2E1B11A4A2ADB.key
diff --git doc/dirmngr.texi doc/dirmngr.texi
index 76be5286c..7866555ff 100644
--- doc/dirmngr.texi
+++ doc/dirmngr.texi
@@ -1096,7 +1096,7 @@ as a binary blob.
 @c In the end the same fucntionality is used, albeit hidden by a couple
 @c of indirection and argument and result code mangling.  It furthere
 @c ingetrages OCSP checking depending on options are the way it is
-@c called.  GPGSM still uses this command but might eventuall switch over
+@c called.  GPGSM still uses this command but might eventually switch over
 @c to CHECKCRL and CHECKOCSP so that ISVALID can be retired.
 @c
 @c
diff --git doc/faq.org doc/faq.org
index ddbeafaf8..2f873e600 100644
--- doc/faq.org
+++ doc/faq.org
@@ -1096,7 +1096,7 @@ update this FAQ in the next month.  See the section "Changes" for recent updates
     As of 1.0.3, keys generated with gpg are created with preferences to
     TWOFISH (and AES since 1.0.4) and that also means that they have the
     capability to use the new MDC encryption method. This will go into
-    OpenPGP soon, and is also suppoted by PGP 7. This new method avoids
+    OpenPGP soon, and is also supported by PGP 7. This new method avoids
     a (not so new) attack on all email encryption systems.
 
     This in turn means that pre-1.0.3 gpg binaries have problems with
diff --git doc/gpg.texi doc/gpg.texi
index 7f55cc7e3..433d6c0e7 100644
--- doc/gpg.texi
+++ doc/gpg.texi
@@ -625,7 +625,7 @@ fingerprint (preferred) or their keyid.
 
 
 @c *******************************************
-@c *******  KEY MANGEMENT COMMANDS  **********
+@c *******  KEY MANAGEMENT COMMANDS  *********
 @c *******************************************
 @node OpenPGP Key Management
 @subsection How to manage your keys
@@ -2612,7 +2612,7 @@ These options are obsolete and have no effect since GnuPG 2.1.
 @item --force-aead
 @opindex force-aead
 Force the use of AEAD encryption over MDC encryption.  AEAD is a
-modern and faster way to do authenticated encrytion than the old MDC
+modern and faster way to do authenticated encryption than the old MDC
 method.  See also options @option{--aead-algo} and
 @option{--chunk-size}.
 
@@ -2768,7 +2768,7 @@ This option is obsolete; it is handled as an alias for @option{--pgp7}
 
 @item --pgp7
 @opindex pgp7
-Set up all options to be as PGP 7 compliant as possible. This allowd
+Set up all options to be as PGP 7 compliant as possible. This allows
 the ciphers IDEA, 3DES, CAST5,AES128, AES192, AES256, and TWOFISH.,
 the hashes MD5, SHA1 and RIPEMD160, and the compression algorithms
 none and ZIP.  This option implies @option{--escape-from-lines} and
@@ -3040,7 +3040,7 @@ same thing.
 @opindex aead-algo
 Specify that the AEAD algorithm @var{name} is to be used.  This is
 useful for symmetric encryption where no key preference are available
-to select the AEAD algorithm.  Runing @command{@gpgname} with option
+to select the AEAD algorithm.  Running @command{@gpgname} with option
 @option{--version} shows the available AEAD algorithms.  In general,
 you do not want to use this option as it allows you to violate the
 OpenPGP standard.  The option @option{--personal-aead-preferences} is
diff --git doc/tools.texi doc/tools.texi
index 7becf67e2..e6b8d2084 100644
--- doc/tools.texi
+++ doc/tools.texi
@@ -1962,7 +1962,7 @@ Extract all files from an encrypted archive.
 
 @item --sign
 @itemx -s
-Make a signed archive from the given files and directories.  Thsi can
+Make a signed archive from the given files and directories.  This can
 be combined with option @option{--encrypt} to create a signed and then
 encrypted archive.
 
@@ -2031,7 +2031,7 @@ linefeed to separate file names.
 
 @item --openpgp
 @opindex openpgp
-This option has no effect becuase OpenPGP encryption and signing is
+This option has no effect because OpenPGP encryption and signing is
 the default.
 
 @item --cms
diff --git doc/wks.texi doc/wks.texi
index 4508ae2a1..51b86ca4a 100644
--- doc/wks.texi
+++ doc/wks.texi
@@ -61,7 +61,7 @@ Service provider.  This is usuallay done to upload a key into a Web
 Key Directory.
 
 With the @option{--supported} command the caller can test whether a
-site supports the Web Key Service.  The argument is an arbitray
+site supports the Web Key Service.  The argument is an arbitrary
 address in the to be tested domain. For example
 @file{foo@@example.net}.  The command returns success if the Web Key
 Service is supported.  The operation is silent; to get diagnostic
@@ -206,7 +206,7 @@ mail is processed.  Commonly this command is used with the option
 @option{--send} to directly send the crerated mails back.  See below
 for an installation example.
 
-The command @option{--cron} is used for regualr cleanup tasks.  For
+The command @option{--cron} is used for regular cleanup tasks.  For
 example non-confirmed requested should be removed after their expire
 time.  It is best to run this command once a day from a cronjob.
 
diff --git doc/yat2m.c doc/yat2m.c
index c7bec338f..660d56c15 100644
--- doc/yat2m.c
+++ doc/yat2m.c
@@ -55,7 +55,7 @@
       .B whateever you want
       @end ifset
 
-    alternativly a special comment may be used:
+    alternatively a special comment may be used:
 
       @c man:.B whatever you want
 
@@ -704,7 +704,7 @@ write_th (FILE *fp)
 
 
 /* Process the texinfo command COMMAND (without the leading @) and
-   write output if needed to FP. REST is the remainer of the line
+   write output if needed to FP. REST is the remainder of the line
    which should either point to an opening brace or to a white space.
    The function returns the number of characters already processed
    from REST.  LEN is the usable length of REST.  TABLE_LEVEL is used to
diff --git g10/armor.c g10/armor.c
index cc8096862..98b870ab9 100644
--- g10/armor.c
+++ g10/armor.c
@@ -1,4 +1,4 @@
-/* armor.c - Armor flter
+/* armor.c - Armor filter
  * Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
  *               2007 Free Software Foundation, Inc.
  *
diff --git g10/call-dirmngr.c g10/call-dirmngr.c
index 388da3d63..8f83c087f 100644
--- g10/call-dirmngr.c
+++ g10/call-dirmngr.c
@@ -1083,7 +1083,7 @@ ks_put_inq_cb (void *opaque, const char *line)
 
 /* Send a key to the configured server.  {DATA,DATLEN} contains the
    key in OpenPGP binary transport format.  If KEYBLOCK is not NULL it
-   has the internal representaion of that key; this is for example
+   has the internal representation of that key; this is for example
    used to convey meta data to LDAP keyservers.  */
 gpg_error_t
 gpg_dirmngr_ks_put (ctrl_t ctrl, void *data, size_t datalen, kbnode_t keyblock)
diff --git g10/cpr.c g10/cpr.c
index 435442636..ed68b3f15 100644
--- g10/cpr.c
+++ g10/cpr.c
@@ -187,7 +187,7 @@ write_status_text (int no, const char *text)
 }
 
 
-/* Write a status line with code NO followed by the outout of the
+/* Write a status line with code NO followed by the output of the
  * printf style FORMAT.  The caller needs to make sure that LFs and
  * CRs are not printed.  */
 void
diff --git g10/decrypt-data.c g10/decrypt-data.c
index a3151b5ed..3951fa794 100644
--- g10/decrypt-data.c
+++ g10/decrypt-data.c
@@ -42,7 +42,7 @@ static int decode_filter ( void *opaque, int control, IOBUF a,
 /* Our context object.  */
 struct decode_filter_context_s
 {
-  /* Recounter (max value is 2).  We need it becuase we do not know
+  /* Recounter (max value is 2).  We need it because we do not know
    * whether the iobuf or the outer control code frees this object
    * first.  */
   int  refcount;
diff --git g10/encrypt.c g10/encrypt.c
index 04a9ab214..972d13c7c 100644
--- g10/encrypt.c
+++ g10/encrypt.c
@@ -732,7 +732,7 @@ encrypt_crypt (ctrl_t ctrl, int filefd, const char *filename,
 
       /* In case 3DES has been selected, print a warning if any key
          does not have a preference for AES.  This should help to
-         indentify why encrypting to several recipients falls back to
+         identify why encrypting to several recipients falls back to
          3DES. */
       if (opt.verbose && cfx.dek->algo == CIPHER_ALGO_3DES)
         warn_missing_aes_from_pklist (pk_list);
@@ -1003,7 +1003,7 @@ encrypt_filter (void *opaque, int control,
 
               /* In case 3DES has been selected, print a warning if
                  any key does not have a preference for AES.  This
-                 should help to indentify why encrypting to several
+                 should help to identify why encrypting to several
                  recipients falls back to 3DES. */
               if (opt.verbose
                   && efx->cfx.dek->algo == CIPHER_ALGO_3DES)
diff --git g10/export.c g10/export.c
index e94e959fb..1c0d84e19 100644
--- g10/export.c
+++ g10/export.c
@@ -97,7 +97,7 @@ cleanup_export_globals (void)
 }
 
 
-/* Option parser for export options.  See parse_options fro
+/* Option parser for export options.  See parse_options for
    details.  */
 int
 parse_export_options(char *str,unsigned int *options,int noisy)
@@ -1171,7 +1171,7 @@ print_status_exported (PKT_public_key *pk)
  * passphrase-protected.  Otherwise, store secret key material in the
  * clear.
  *
- * CACHE_NONCE_ADDR is used to share nonce for multple key retrievals.
+ * CACHE_NONCE_ADDR is used to share nonce for multiple key retrievals.
  */
 gpg_error_t
 receive_seckey_from_agent (ctrl_t ctrl, gcry_cipher_hd_t cipherhd,
diff --git g10/getkey.c g10/getkey.c
index ea2dee21d..75ce9cb38 100644
--- g10/getkey.c
+++ g10/getkey.c
@@ -60,7 +60,7 @@ struct getkey_ctx_s
      search or not.  A search that is exact requires that a key or
      subkey meet all of the specified criteria.  A search that is not
      exact allows selecting a different key or subkey from the
-     keyblock that matched the critera.  Further, an exact search
+     keyblock that matched the criteria.  Further, an exact search
      returns the key or subkey that matched whereas a non-exact search
      typically returns the primary key.  See finish_lookup for
      details.  */
@@ -3364,7 +3364,7 @@ merge_selfsigs (ctrl_t ctrl, kbnode_t keyblock)
  *
  *  1. No requested usage and no primary key requested
  *     Examples for this case are that we have a keyID to be used
- *     for decrytion or verification.
+ *     for decryption or verification.
  *  2. No usage but primary key requested
  *     This is the case for all functions which work on an
  *     entire keyblock, e.g. for editing or listing
diff --git g10/gpg.c g10/gpg.c
index f04a3400a..89d3ca19e 100644
--- g10/gpg.c
+++ g10/gpg.c
@@ -3891,7 +3891,7 @@ main (int argc, char **argv)
        keygen_set_std_prefs(pers_compress_list,PREFTYPE_ZIP))
       log_error(_("invalid personal compress preferences\n"));
 
-    /* Check chunk size.  Please fix also the man page if you chnage
+    /* Check chunk size.  Please fix also the man page if you change
      * the default.  The limits are given by the specs.  */
     if (!opt.chunk_size)
       opt.chunk_size = 27; /* Default to the suggested max of 128 MiB.  */
diff --git g10/key-clean.c g10/key-clean.c
index f66a0dbb4..d701a6665 100644
--- g10/key-clean.c
+++ g10/key-clean.c
@@ -500,7 +500,7 @@ clean_one_subkey_dupsigs (ctrl_t ctrl, kbnode_t subkeynode)
     log_debug ("\tchecking subkey %08lX for dupsigs\n",
                (ulong) keyid_from_pk (pk, NULL));
 
-  /* First check that the choosen flag has been set.  Note that we
+  /* First check that the chosen flag has been set.  Note that we
    * only look at plain signatures so to keep all revocation
    * signatures which may carry important information.  */
   for (node = subkeynode->next;
@@ -519,7 +519,7 @@ clean_one_subkey_dupsigs (ctrl_t ctrl, kbnode_t subkeynode)
     }
 
   if (!any_choosen)
-    return 0; /* Ooops no choosen flag set - we can't decide.  */
+    return 0; /* Ooops no chosen flag set - we can't decide.  */
 
   for (node = subkeynode->next;
        node && !(node->pkt->pkttype == PKT_PUBLIC_SUBKEY
diff --git g10/key-clean.h g10/key-clean.h
index a0fb76950..c4f164928 100644
--- g10/key-clean.h
+++ g10/key-clean.h
@@ -23,7 +23,7 @@
 
 #include "gpg.h"
 
-/* No explict cleaning.  */
+/* No explicit cleaning.  */
 #define KEY_CLEAN_NONE      0
 /* Remove only invalid subkeys (ie. missing key-bindings) */
 #define KEY_CLEAN_INVALID   1
diff --git g10/mainproc.c g10/mainproc.c
index 6ec15894d..5b7bc9555 100644
--- g10/mainproc.c
+++ g10/mainproc.c
@@ -811,7 +811,7 @@ proc_plaintext( CTX c, PACKET *pkt )
   int any, clearsig, rc;
   kbnode_t n;
 
-  /* This is a literal data packet.  Bumb a counter for later checks.  */
+  /* This is a literal data packet.  Bump a counter for later checks.  */
   literals_seen++;
 
   if (pt->namelen == 8 && !memcmp( pt->name, "_CONSOLE", 8))
diff --git g10/misc.c g10/misc.c
index d7a3ee3f2..f59cb8082 100644
--- g10/misc.c
+++ g10/misc.c
@@ -549,7 +549,7 @@ openpgp_cipher_blocklen (cipher_algo_t algo)
 
 /****************
  * Wrapper around the libgcrypt function with additional checks on
- * the OpenPGP contraints for the algo ID.
+ * the OpenPGP constraints for the algo ID.
  */
 int
 openpgp_cipher_test_algo (cipher_algo_t algo)
@@ -712,7 +712,7 @@ openpgp_pk_test_algo2 (pubkey_algo_t algo, unsigned int use)
 #endif
 
     case PUBKEY_ALGO_ELGAMAL:
-      /* Dont't allow type 20 keys unless in rfc2440 mode.  */
+      /* Don't allow type 20 keys unless in rfc2440 mode.  */
       if (RFC2440)
         ga = GCRY_PK_ELG;
       break;
diff --git g10/packet.h g10/packet.h
index 6e1438be6..d088bf432 100644
--- g10/packet.h
+++ g10/packet.h
@@ -244,7 +244,7 @@ typedef struct
   const byte *trust_regexp;
   struct revocation_key *revkey;
   int numrevkeys;
-  int help_counter;          /* Used internally bu some fucntions.  */
+  int help_counter;          /* Used internally by some functions.  */
   pka_info_t *pka_info;      /* Malloced PKA data or NULL if not
                                 available.  See also flags.pka_tried. */
   char *signers_uid;         /* Malloced value of the SIGNERS_UID
diff --git g10/parse-packet.c g10/parse-packet.c
index 92c65294a..0a7aec358 100644
--- g10/parse-packet.c
+++ g10/parse-packet.c
@@ -3180,7 +3180,7 @@ parse_plaintext (IOBUF inp, int pkttype, unsigned long pktlen,
 	  pt->name[i] = c;
     }
   /* Fill up NAME so that a check with valgrind won't complain about
-   * reading from uninitalized memory.  This case may be triggred by
+   * reading from uninitialized memory.  This case may be triggred by
    * corrupted packets.  */
   for (; i < namelen; i++)
     pt->name[i] = 0;
diff --git g10/seskey.c g10/seskey.c
index 15490179d..fb71ad5cd 100644
--- g10/seskey.c
+++ g10/seskey.c
@@ -95,7 +95,7 @@ encode_session_key (int openpgp_pk_algo, DEK *dek, unsigned int nbits)
      output be a multiple of 8 bytes.  */
   if (openpgp_pk_algo == PUBKEY_ALGO_ECDH)
     {
-      /* Pad to 8 byte granulatiry; the padding byte is the number of
+      /* Pad to 8 byte granularity; the padding byte is the number of
        * padded bytes.
        *
        * A  DEK(k bytes)  CSUM(2 bytes) 0x 0x 0x 0x ... 0x
@@ -143,7 +143,7 @@ encode_session_key (int openpgp_pk_algo, DEK *dek, unsigned int nbits)
    *
    *	   0  2  RND(i bytes)  0  A  DEK(k bytes)  CSUM(2 bytes)
    *
-   * (But how can we store the leading 0 - the external representaion
+   * (But how can we store the leading 0 - the external representation
    *  of MPIs doesn't allow leading zeroes =:-)
    *
    * RND are (at least 1) non-zero random bytes.
diff --git g10/tdbio.c g10/tdbio.c
index fed0cf5ab..00f2953b0 100644
--- g10/tdbio.c
+++ g10/tdbio.c
@@ -106,7 +106,7 @@ struct cmp_xdir_struct
 static char *db_name;
 
 /* The handle for locking the trustdb file and a counter to record how
- * often this lock has been taken.  That counter is required becuase
+ * often this lock has been taken.  That counter is required because
  * dotlock does not implemen recursive locks.  */
 static dotlock_t lockhandle;
 static unsigned int is_locked;
@@ -1118,7 +1118,7 @@ upd_hashtable (ctrl_t ctrl, ulong table, byte *key, int keylen, ulong newrecnum)
 
               if (rec.r.hlst.next)
                 {
-                  /* read the next reord of the list.  */
+                  /* read the next record of the list.  */
                   rc = tdbio_read_record (rec.r.hlst.next, &rec, RECTYPE_HLST);
                   if (rc)
                     {
diff --git g10/trustdb.c g10/trustdb.c
index 8ef6db542..c46dc50c8 100644
--- g10/trustdb.c
+++ g10/trustdb.c
@@ -1506,7 +1506,7 @@ store_validation_status (ctrl_t ctrl, int depth,
 /* Returns a sanitized copy of the regexp (which might be "", but not
    NULL). */
 #ifndef DISABLE_REGEX
-/* Operator charactors except '.' and backslash.
+/* Operator characters except '.' and backslash.
    See regex(7) on BSD.  */
 #define REGEXP_OPERATOR_CHARS "^[$()|*+?{"
 
diff --git g10/verify.c g10/verify.c
index caeb1a244..73ac4bad8 100644
--- g10/verify.c
+++ g10/verify.c
@@ -69,7 +69,7 @@ verify_signatures (ctrl_t ctrl, int nfiles, char **files )
      * we can do it is by reading one byte from stdin and then unget
      * it; the problem here is that we may be reading from the
      * terminal (which could be detected using isatty() but won't work
-     * when under contol of a pty using program (e.g. expect)) and
+     * when under control of a pty using program (e.g. expect)) and
      * might get us in trouble when stdin is used for another purpose
      * (--passphrase-fd 0).  So we have to break with the behaviour
      * prior to gpg 1.0.4 by assuming that case 3 is a normal
diff --git g13/call-syshelp.c g13/call-syshelp.c
index b160ba32d..a69573bd1 100644
--- g13/call-syshelp.c
+++ g13/call-syshelp.c
@@ -174,7 +174,7 @@ call_syshelp_release (ctrl_t ctrl)
 
 
 
-/* Staus callback for call_syshelp_find_device.  */
+/* Status callback for call_syshelp_find_device.  */
 static gpg_error_t
 finddevice_status_cb (void *opaque, const char *line)
 {
diff --git g13/runner.c g13/runner.c
index 138269d21..11bbc8f26 100644
--- g13/runner.c
+++ g13/runner.c
@@ -278,7 +278,7 @@ runner_set_pid (runner_t runner, pid_t pid)
 }
 
 
-/* Register the engine handler fucntions HANDLER and HANDLER_CLEANUP
+/* Register the engine handler functions HANDLER and HANDLER_CLEANUP
    and its private HANDLER_DATA with RUNNER.  */
 void
 runner_set_handler (runner_t runner,
diff --git kbx/keybox-blob.c kbx/keybox-blob.c
index 687421219..817253590 100644
--- kbx/keybox-blob.c
+++ kbx/keybox-blob.c
@@ -616,7 +616,7 @@ create_blob_header (KEYBOXBLOB blob, int blobtype, int as_ephemeral)
   if (blobtype == KEYBOX_BLOBTYPE_X509)
     {
       /* We don't want to point to ASN.1 encoded UserIDs (DNs) but to
-         the utf-8 string represenation of them */
+         the utf-8 string representation of them */
       for (i=0; i < blob->nuids; i++ )
         {
           if (blob->uids[i].name)
diff --git kbx/keybox-errors.c kbx/keybox-errors.c
index ce2b498d0..cb5a092d9 100644
--- kbx/keybox-errors.c
+++ kbx/keybox-errors.c
@@ -8,7 +8,7 @@
  * keybox_strerror:
  * @err:  Error code
  *
- * This function returns a textual representaion of the given
+ * This function returns a textual representation of the given
  * errorcode. If this is an unknown value, a string with the value
  * is returned (Beware: it is hold in a static buffer).
  *
diff --git kbx/keybox-search.c kbx/keybox-search.c
index e309cce98..0a050ff9b 100644
--- kbx/keybox-search.c
+++ kbx/keybox-search.c
@@ -1069,7 +1069,7 @@ keybox_search (KEYBOX_HANDLE hd, KEYBOX_SEARCH_DESC *desc, size_t ndesc,
 
 
 /* Return the last found keyblock.  Returns 0 on success and stores a
- * new iobuf at R_IOBUF.  R_UID_NO and R_PK_NO are used to retun the
+ * new iobuf at R_IOBUF.  R_UID_NO and R_PK_NO are used to return the
  * number of the key or user id which was matched the search criteria;
  * if not known they are set to 0. */
 gpg_error_t
diff --git kbx/mkerrors kbx/mkerrors
index 629485ae0..c0bca108c 100755
--- kbx/mkerrors
+++ kbx/mkerrors
@@ -29,7 +29,7 @@ cat <<EOF
  * keybox_strerror:
  * @err:  Error code
  *
- * This function returns a textual representaion of the given
+ * This function returns a textual representation of the given
  * errorcode. If this is an unknown value, a string with the value
  * is returned (Beware: it is hold in a static buffer).
  *
diff --git m4/gpg-error.m4 m4/gpg-error.m4
index 1661204c2..8ba24b71a 100644
--- m4/gpg-error.m4
+++ m4/gpg-error.m4
@@ -17,7 +17,7 @@ dnl                   [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
 dnl
 dnl Test for libgpg-error and define GPG_ERROR_CFLAGS, GPG_ERROR_LIBS,
 dnl GPG_ERROR_MT_CFLAGS, and GPG_ERROR_MT_LIBS.  The _MT_ variants are
-dnl used for programs requireing real multi thread support.
+dnl used for programs requiring real multi thread support.
 dnl
 dnl If a prefix option is not used, the config script is first
 dnl searched in $SYSROOT/bin and then along $PATH.  If the used
diff --git m4/ksba.m4 m4/ksba.m4
index 3e14e6744..8cb49a391 100644
--- m4/ksba.m4
+++ m4/ksba.m4
@@ -13,7 +13,7 @@
 dnl AM_PATH_KSBA([MINIMUM-VERSION,
 dnl              [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
 dnl Test for libksba and define KSBA_CFLAGS and KSBA_LIBS
-dnl MINIMUM-VERSION is a string with the version number optionalliy prefixed
+dnl MINIMUM-VERSION is a string with the version number optionally prefixed
 dnl with the API version to also check the API compatibility. Example:
 dnl a MINIMUM-VERSION of 1:1.0.7 won't pass the test unless the installed
 dnl version of libksba is at least 1.0.7 *and* the API number is 1.  Using
diff --git m4/libgcrypt.m4 m4/libgcrypt.m4
index d89fe1137..dd167f814 100644
--- m4/libgcrypt.m4
+++ m4/libgcrypt.m4
@@ -15,7 +15,7 @@
 dnl AM_PATH_LIBGCRYPT([MINIMUM-VERSION,
 dnl                   [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
 dnl Test for libgcrypt and define LIBGCRYPT_CFLAGS and LIBGCRYPT_LIBS.
-dnl MINIMUM-VERSION is a string with the version number optionalliy prefixed
+dnl MINIMUM-VERSION is a string with the version number optionally prefixed
 dnl with the API version to also check the API compatibility. Example:
 dnl a MINIMUM-VERSION of 1:1.2.5 won't pass the test unless the installed
 dnl version of libgcrypt is at least 1.2.5 *and* the API number is 1.  Using
diff --git m4/ntbtls.m4 m4/ntbtls.m4
index 0a30d9200..4a4b5da30 100644
--- m4/ntbtls.m4
+++ m4/ntbtls.m4
@@ -14,7 +14,7 @@ dnl AM_PATH_NTBTLS([MINIMUM-VERSION,
 dnl                   [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND ]]])
 dnl
 dnl Test for NTBTLS and define NTBTLS_CFLAGS and NTBTLS_LIBS.
-dnl MINIMUM-VERSION is a string with the version number optionalliy prefixed
+dnl MINIMUM-VERSION is a string with the version number optionally prefixed
 dnl with the API version to also check the API compatibility. Example:
 dnl a MINIMUM-VERSION of 1:1.2.5 won't pass the test unless the installed
 dnl version of ntbtls is at least 1.2.5 *and* the API number is 1.  Using
diff --git scd/apdu.c scd/apdu.c
index ce7f41f61..4d2323572 100644
--- scd/apdu.c
+++ scd/apdu.c
@@ -2612,7 +2612,7 @@ send_apdu (int slot, unsigned char *apdu, size_t apdulen,
 }
 
 
-/* Core APDU tranceiver function. Parameters are described at
+/* Core APDU transceiver function. Parameters are described at
    apdu_send_le with the exception of PININFO which indicates pinpad
    related operations if not NULL.  If EXTENDED_MODE is not 0
    command chaining or extended length will be used according to these
diff --git scd/app-openpgp.c scd/app-openpgp.c
index c17452555..cbf69768f 100644
--- scd/app-openpgp.c
+++ scd/app-openpgp.c
@@ -640,7 +640,7 @@ count_bits (const unsigned char *a, size_t len)
     Where FLAGS is a plain hexadecimal number representing flag values.
     The lsb is here the rightmost bit.  Defined flags bits are:
 
-      Bit 0 = CHV1 and CHV2 are not syncronized
+      Bit 0 = CHV1 and CHV2 are not synchronized
       Bit 1 = CHV2 has been set to the default PIN of "123456"
               (this implies that bit 0 is also set).
 

--- scd/ccid-driver.c
+++ scd/ccid-driver.c
@@ -1921,7 +1921,7 @@ bulk_out (ccid_driver_t handle, unsigned char *msg, size_t msglen,
    is the sequence number used to send the request and EXPECTED_TYPE
    the type of message we expect. Does checks on the ccid
    header. TIMEOUT is the timeout value in ms. NO_DEBUG may be set to
-   avoid debug messages in case of no error; this can be overriden
+   avoid debug messages in case of no error; this can be overridden
    with a glibal debug level of at least 3. Returns 0 on success. */
 static int
 bulk_in (ccid_driver_t handle, unsigned char *buffer, size_t length,
@@ -2928,7 +2928,7 @@ ccid_transceive_apdu_level (ccid_driver_t handle,
    bit 3     unused
    bit 2..0  Source Node Address (SAD)
 
-   If node adresses are not used, SAD and DAD should be set to 0 on
+   If node addresses are not used, SAD and DAD should be set to 0 on
    the first block sent to the card.  If they are used they should
    have different values (0 for one is okay); that first block sets up
    the addresses of the nodes.
@@ -3270,7 +3270,7 @@ ccid_transceive (ccid_driver_t handle,
               /* Wait time extension request. */
               unsigned char bwi = tpdu[3];
 
-              /* Check if it's unsual value which can't be expressed in ATR.  */
+              /* Check if it's unusual value which can't be expressed in ATR.  */
               if (bwi > 15)
                 wait_more = 1;
 
diff --git scd/iso7816.c scd/iso7816.c
index 29208c254..01faca5b4 100644
--- scd/iso7816.c
+++ scd/iso7816.c
@@ -427,7 +427,7 @@ iso7816_put_data_odd (int slot, int extended_mode, int tag,
 
 /* Manage Security Environment.  This is a weird operation and there
    is no easy abstraction for it.  Furthermore, some card seem to have
-   a different interpreation of 7816-8 and thus we resort to let the
+   a different interpretation of 7816-8 and thus we resort to let the
    caller decide what to do. */
 gpg_error_t
 iso7816_manage_security_env (int slot, int p1, int p2,
@@ -445,7 +445,7 @@ iso7816_manage_security_env (int slot, int p1, int p2,
 
 
 /* Perform the security operation COMPUTE DIGITAL SIGANTURE.  On
-   success 0 is returned and the data is availavle in a newly
+   success 0 is returned and the data is available in a newly
    allocated buffer stored at RESULT with its length stored at
    RESULTLEN.  For LE see do_generate_keypair. */
 gpg_error_t
diff --git scd/scdaemon.c scd/scdaemon.c
index 8f8a02619..507108db0 100644
--- scd/scdaemon.c
+++ scd/scdaemon.c
@@ -1069,7 +1069,7 @@ handle_signal (int signo)
 /* Create a name for the socket.  We check for valid characters as
    well as against a maximum allowed length for a unix domain socket
    is done.  The function terminates the process in case of an error.
-   Retunrs: Pointer to an allcoated string with the absolute name of
+   Returns: Pointer to an allocated string with the absolute name of
    the socket used.  */
 static char *
 create_socket_name (char *standard_name)
diff --git sm/call-dirmngr.c sm/call-dirmngr.c
index 3a38bca50..bff7dd652 100644
--- sm/call-dirmngr.c
+++ sm/call-dirmngr.c
@@ -474,7 +474,7 @@ isvalid_status_cb (void *opaque, const char *line)
     {
       parm->seen++;
       if (!*s || !unhexify_fpr (s, parm->fpr))
-        parm->seen++; /* Bumb it to indicate an error. */
+        parm->seen++; /* Bump it to indicate an error. */
     }
   return 0;
 }
diff --git sm/certchain.c sm/certchain.c
index 4e18caf55..b728ef2c5 100644
--- sm/certchain.c
+++ sm/certchain.c
@@ -669,7 +669,7 @@ find_up (ctrl_t ctrl, KEYDB_HANDLE kh,
             log_debug ("  found via authid and sn+issuer\n");
 
           /* In case of an error, try to get the certificate from the
-             dirmngr.  That is done by trying to put that certifcate
+             dirmngr.  That is done by trying to put that certificate
              into the ephemeral DB and let the code below do the
              actual retrieve.  Thus there is no error checking.
              Skipped in find_next mode as usual. */
@@ -908,7 +908,7 @@ is_root_cert (ksba_cert_t cert, const char *issuerdn, const char *subjectdn)
     {
       if (gpg_err_code (err) == GPG_ERR_NO_DATA)
         return 1; /* Yes. Without a authorityKeyIdentifier this needs
-                     to be the Root certifcate (our trust anchor).  */
+                     to be the Root certificate (our trust anchor).  */
       log_error ("error getting authorityKeyIdentifier: %s\n",
                  gpg_strerror (err));
       return 0; /* Well, it is broken anyway.  Return No. */
@@ -1103,7 +1103,7 @@ check_validity_period (ksba_isotime_t current_time,
 }
 
 /* This is a variant of check_validity_period used with the chain
-   model.  The dextra contraint here is that notBefore and notAfter
+   model.  The dextra constraint here is that notBefore and notAfter
    must exists and if the additional argument CHECK_TIME is given this
    time is used to check the validity period of SUBJECT_CERT.  */
 static gpg_error_t
@@ -1171,7 +1171,7 @@ check_validity_period_cm (ksba_isotime_t current_time,
           || strcmp (check_time, not_after) > 0))
     {
       /* Note that we don't need a case for the root certificate
-         because its own consitency has already been checked.  */
+         because its own consistency has already been checked.  */
       do_list(opt.ignore_expiration?0:1, listmode, listfp,
               depth == 0 ?
               _("signature not created during lifetime of certificate") :
@@ -1553,7 +1553,7 @@ do_validate_chain (ctrl_t ctrl, ksba_cert_t cert, ksba_isotime_t checktime_arg,
           if (rc)
             goto leave;
 
-          break;  /* Okay: a self-signed certicate is an end-point. */
+          break;  /* Okay: a self-signed certificate is an end-point. */
         } /* End is_root.  */
 
 
diff --git sm/certlist.c sm/certlist.c
index c9e275e9d..49caa6bb8 100644
--- sm/certlist.c
+++ sm/certlist.c
@@ -395,7 +395,7 @@ gpgsm_add_to_certlist (ctrl_t ctrl, const char *name, int secret,
 
                      Further we ignore them if they are due to an
                      identical certificate (which may happen if a
-                     certificate is accidential duplicated in the
+                     certificate is accidental duplicated in the
                      keybox).  */
                   if (!keydb_get_cert (kh, &cert2))
                     {
@@ -533,7 +533,7 @@ gpgsm_find_cert (ctrl_t ctrl,
             }
 
           /* If we don't have the KEYID filter we need to check for
-             ambiguous search results.  Note, that it is somehwat
+             ambiguous search results.  Note, that it is somewhat
              reasonable to assume that a specification of a KEYID
              won't lead to ambiguous names. */
           if (!rc && !keyid)
diff --git sm/gpgsm.c sm/gpgsm.c
index b0547876a..db3154013 100644
--- sm/gpgsm.c
+++ sm/gpgsm.c
@@ -1571,7 +1571,7 @@ main ( int argc, char **argv)
 
   set_debug ();
 
-  /* Although we always use gpgsm_exit, we better install a regualr
+  /* Although we always use gpgsm_exit, we better install a regular
      exit handler so that at least the secure memory gets wiped
      out. */
   if (atexit (emergency_cleanup))
diff --git sm/gpgsm.h sm/gpgsm.h
index d3fbde515..7a5e4917d 100644
--- sm/gpgsm.h
+++ sm/gpgsm.h
@@ -76,7 +76,7 @@ struct
   const char *protect_tool_program;
   char *outfile;    /* name of output file */
 
-  int with_key_data;/* include raw key in the column delimted output */
+  int with_key_data;/* include raw key in the column delimited output */
 
   int fingerprint;  /* list fingerprints in all key listings */
 
diff --git sm/keydb.c sm/keydb.c
index d85679a3b..a6ea9f77f 100644
--- sm/keydb.c
+++ sm/keydb.c
@@ -106,7 +106,7 @@ try_make_homedir (const char *fname)
 
 
 /* Handle the creation of a keybox if it does not yet exist.  Take
-   into acount that other processes might have the keybox already
+   into account that other processes might have the keybox already
    locked.  This lock check does not work if the directory itself is
    not yet available.  If R_CREATED is not NULL it will be set to true
    if the function created a new keybox.  */
diff --git tests/asschk.c tests/asschk.c
index 65828e5b2..4f3124414 100644
--- tests/asschk.c
+++ tests/asschk.c
@@ -30,7 +30,7 @@
    expanded once and non existing macros expand to the empty string.
    A macro is dereferenced by prefixing its name with a dollar sign;
    the end of the name is currently indicated by a white space, a
-   dollar sign or a slash.  To use a dollor sign verbatim, double it.
+   dollar sign or a slash.  To use a dollar sign verbatim, double it.
 
    A macro is assigned by prefixing a statement with the macro name
    and an equal sign.  The value is assigned verbatim if it does not
@@ -47,7 +47,7 @@
 
    [<name> =] <statement> [<args>]
 
-   If NAME is not specifed but the statement returns a value it is
+   If NAME is not specified but the statement returns a value it is
    assigned to the name "?" so that it can be referenced using "$?".
    The following commands are implemented:
 
@@ -397,7 +397,7 @@ write_assuan (int fd, const char *line)
 
 /* Start the server with path PGMNAME and connect its stdout and
    strerr to a newly created pipes; the file descriptors are then
-   store in the gloabl variables SERVER_SEND_FD and
+   store in the global variables SERVER_SEND_FD and
    SERVER_RECV_FD. The initial handcheck is performed.*/
 static void
 start_server (const char *pgmname)
@@ -468,7 +468,7 @@ start_server (const char *pgmname)
 
 
 
-/* Script intepreter. */
+/* Script interpreter. */
 
 static void
 unset_var (const char *name)
diff --git tests/sm-verify tests/sm-verify
index b06dc16a4..fa0932300 100644
--- tests/sm-verify
+++ tests/sm-verify
@@ -90,7 +90,7 @@ fail-if !$trusted
 send BYE
 expect-ok
 
-# We als have tampered version.
+# We also have tampered version.
 sig = openfile $srcdir/text-2.osig-bad.pem
 
 pipeserver $GPGSM
diff --git tools/gpg-check-pattern.c tools/gpg-check-pattern.c
index 4db8f3706..dee5d5d47 100644
--- tools/gpg-check-pattern.c
+++ tools/gpg-check-pattern.c
@@ -91,7 +91,7 @@ static struct
 enum {
   PAT_NULL,    /* Indicates end of the array.  */
   PAT_STRING,  /* The pattern is a simple string.  */
-  PAT_REGEX    /* The pattern is an extended regualr expression. */
+  PAT_REGEX    /* The pattern is an extended regular expression. */
 };
 
 
diff --git tools/gpgconf.c tools/gpgconf.c
index 59085d8b5..df3ae8cab 100644
--- tools/gpgconf.c
+++ tools/gpgconf.c
@@ -823,7 +823,7 @@ main (int argc, char **argv)
           ;
         else if (rmdir (socketdir))
           {
-            /* If the director is not empty we first try to delet
+            /* If the director is not empty we first try to delete
              * socket files.  */
             err = gpg_error_from_syserror ();
             if (gpg_err_code (err) == GPG_ERR_ENOTEMPTY
diff --git tools/gpgtar.h tools/gpgtar.h
index 8cbe80bbb..28d3d88b1 100644
--- tools/gpgtar.h
+++ tools/gpgtar.h
@@ -88,7 +88,7 @@ typedef enum
   } typeflag_t;
 
 
-/* The internal represenation of a TAR header.  */
+/* The internal representation of a TAR header.  */
 struct tar_header_s;
 typedef struct tar_header_s *tar_header_t;
 struct tar_header_s
diff --git tools/mime-parser.c tools/mime-parser.c
index a151dc65e..766fc4105 100644
--- tools/mime-parser.c
+++ tools/mime-parser.c
@@ -50,7 +50,7 @@ struct mime_parser_context_s
 {
   void *cookie;                /* Cookie passed to all callbacks.  */
 
-  /* The callback to announce the transation from header to body.  */
+  /* The callback to announce the transaction from header to body.  */
   gpg_error_t (*t2body) (void *cookie, int level);
 
   /* The callback to announce a new part.  */
diff --git tools/no-libgcrypt.c tools/no-libgcrypt.c
index 873996889..3b577567a 100644
--- tools/no-libgcrypt.c
+++ tools/no-libgcrypt.c
@@ -114,7 +114,7 @@ gcry_free (void *a)
 
 
 /* We need this dummy because exechelp.c uses gcry_control to
-   terminate the secure memeory.  */
+   terminate the secure memory.  */
 gcry_error_t
 gcry_control (enum gcry_ctl_cmds cmd, ...)
 {
diff --git tools/rfc822parse.c tools/rfc822parse.c
index e8cdb0215..bfd82d12f 100644
--- tools/rfc822parse.c
+++ tools/rfc822parse.c
@@ -167,7 +167,7 @@ my_stpcpy (char *a,const char *b)
 #endif
 
 
-/* If a callback has been registerd, call it for the event of type
+/* If a callback has been registered, call it for the event of type
    EVENT. */
 static int
 do_callback (rfc822parse_t msg, rfc822parse_event_t event)
@@ -578,7 +578,7 @@ rfc822parse_get_field (rfc822parse_t msg, const char *name, int which,
 
 /****************
  * Enumerate all header.  Caller has to provide the address of a pointer
- * which has to be initialzed to NULL, the caller should then never change this
+ * which has to be initialized to NULL, the caller should then never change this
  * pointer until he has closed the enumeration by passing again the address
  * of the pointer but with msg set to NULL.
  * The function returns pointers to all the header lines or NULL when
@@ -616,7 +616,7 @@ rfc822parse_enum_header_lines (rfc822parse_t msg, void **context)
  *	   >0 : Retrieve the n-th field
 
  * RPREV may be used to return the predecessor of the returned field;
- * which may be NULL for the very first one. It has to be initialzed
+ * which may be NULL for the very first one. It has to be initialized
  * to either NULL in which case the search start at the first header line,
  * or it may point to a headerline, where the search should start
  */
diff --git tools/wks-util.c tools/wks-util.c
index 3fd824c1a..862cd33a3 100644
--- tools/wks-util.c
+++ tools/wks-util.c
@@ -65,7 +65,7 @@ wks_set_status_fd (int fd)
 }
 
 
-/* Write a status line with code NO followed by the outout of the
+/* Write a status line with code NO followed by the output of the
  * printf style FORMAT.  The caller needs to make sure that LFs and
  * CRs are not printed.  */
 void
